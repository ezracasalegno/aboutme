<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starship Mars Run</title>
    <!-- Use the Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Global CSS for space theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Pure black background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Fullscreen height */
            width: 100vw; /* Fullscreen width */
            margin: 0;
            padding: 0;
            color: #ffffff;
            overflow: hidden; 
        }

        /* Game Container Styling - Takes up the entire viewport */
        .game-container {
            position: relative;
            background-color: #000000; /* Pure black canvas background */
            box-shadow: none;
            border: none;
            border-radius: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD and Score Styling */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #00ffff; /* Cyan color for score */
            z-index: 10;
        }

        .score-display, .level-display {
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.7);
        }

        /* NEW LAYOUT CONTAINER for Instructions (Left) and Controls (Right) */
        .controls-overlay {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between; /* Pushes content to corners */
            align-items: flex-end;
            padding: 0 20px; /* Padding from screen edges */
            box-sizing: border-box;
            z-index: 30;
        }
        
        /* Instructions Box (Bottom Left) */
        .instructions-box {
            width: 45%; 
            max-width: 300px;
            text-align: left;
        }

        .instructions {
            background: rgba(26, 26, 56, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #cccccc;
            margin-bottom: 0;
        }
        
        /* Mobile Controls Wrapper (Bottom Right) */
        .mobile-controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px; 
            width: 45%; 
            max-width: 400px;
        }

        /* Game Over Modal */
        .game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 40;
            text-align: center;
        }

        .game-over-modal h3 {
            color: #ff0077; 
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .game-over-modal p {
            color: #00ffff;
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        /* Button Styling */
        button {
            background: linear-gradient(45deg, #00ffff, #00aaff);
            color: #0d0d1e;
            border: none;
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
        }

        button:hover {
            background: linear-gradient(45deg, #00aaff, #00ffff);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.6);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.4);
        }

        /* Internal Controls Styling */
        .horizontal-controls, .vertical-controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        .horizontal-controls button, .vertical-controls button {
            width: 48%;
            padding: 12px 0;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- Game HUD -->
        <div class="hud">
            <span class="score-display" id="score">Score: 0</span>
            <span class="level-display" id="level">Level: 1</span>
        </div>

        <!-- Canvas for the game -->
        <canvas id="gameCanvas"></canvas>

        <!-- Controls and Instructions OVERLAY -->
        <div class="controls-overlay">
            
            <!-- Bottom Left Instructions -->
            <div class="instructions-box">
                <div class="instructions">
                    Use **W A S D** or **Arrow keys** for 360-degree movement. **Click the game screen once** to ensure keyboard controls are active!
                </div>
            </div>
            
            <!-- Bottom Right Mobile/Button Controls -->
            <div class="mobile-controls-wrapper">
                <div class="vertical-controls">
                    <button onmousedown="moveUp(true)" onmouseup="moveUp(false)" ontouchstart="moveUp(true)" ontouchend="moveUp(false)">
                        &uarr; UP (W)
                    </button>
                    <button onmousedown="moveDown(true)" onmouseup="moveDown(false)" ontouchstart="moveDown(true)" ontouchend="moveDown(false)">
                        DOWN (S) &darr;
                    </button>
                </div>
                <div class="horizontal-controls">
                    <button onmousedown="moveLeft(true)" onmouseup="moveLeft(false)" ontouchstart="moveLeft(true)" ontouchend="moveLeft(false)">
                        &larr; LEFT (A)
                    </button>
                    <button onmousedown="moveRight(true)" onmouseup="moveRight(false)" ontouchstart="moveRight(true)" ontouchend="moveRight(false)">
                        RIGHT (D) &rarr;
                    </button>
                </div>
            </div>
        </div>
        

        <!-- Game Over Modal (Initially hidden) -->
        <div class="game-over-modal" id="gameOverModal" style="display: none;">
            <h3 class="final-message">MISSION FAILED</h3>
            <p>Starship Impacted! Final Score: <span id="finalScore">0</span></p>
            <button onclick="startGame()">RESTART MISSION</button>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreDisplay = document.getElementById('finalScore');

        // Initial Canvas Sizing
        let CW, CH; 
        
        let score = 0;
        let isRunning = false;
        let lastTime = 0;
        let scoreInterval = null;
        
        // Game Difficulty Settings
        let globalSpeed = 2;
        let obstacleSpawnRate = 60; // Base spawn rate is faster (was 80)
        let difficultyLevel = 1;
        let obstacleCount = 0;

        // Player (Starship)
        const rocket = {
            width: 30,
            height: 80,
            x: 0,
            y: 0,
            speed: 5,
            velX: 0,
            velY: 0
        };

        // Obstacle Array
        let obstacles = [];

        // Input Handler
        let keys = { A: false, D: false, W: false, S: false, ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };

        // --- Utility Functions ---

        /**
         * Resizes the canvas to match its container size (full viewport).
         */
        function resizeCanvas() {
            CW = canvas.width = window.innerWidth;
            CH = canvas.height = window.innerHeight;
            
            // Re-center rocket on resize (near the bottom 3/4ths mark)
            rocket.x = CW / 2 - rocket.width / 2;
            rocket.y = CH * 0.75 - rocket.height / 2;
        }
        window.addEventListener('resize', resizeCanvas);


        // --- Player Movement Functions (Accessible globally for button clicks) ---
        
        // KEYBOARD LISTENERS
        document.addEventListener('keydown', (e) => {
            // Preventing default scroll action for arrows/WASD
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }

            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                keys.A = keys.ArrowLeft = true;
            }
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                keys.D = keys.ArrowRight = true;
            }
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                keys.W = keys.ArrowUp = true;
            }
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                keys.S = keys.ArrowDown = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                keys.A = keys.ArrowLeft = false;
            }
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                keys.D = keys.ArrowRight = false;
            }
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                keys.W = keys.ArrowUp = false;
            }
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                keys.S = keys.ArrowDown = false;
            }
        });
        
        // Mobile/Touch/Mouse handlers
        window.moveLeft = (isDown) => { keys.A = keys.ArrowLeft = isDown; };
        window.moveRight = (isDown) => { keys.D = keys.ArrowRight = isDown; };
        window.moveUp = (isDown) => { keys.W = keys.ArrowUp = isDown; };
        window.moveDown = (isDown) => { keys.S = keys.ArrowDown = isDown; };


        // --- Game Components: Starship & Asteroid ---

        /**
         * Draws the animated engine thrust coming out of the bottom of the rocket.
         */
        function drawEngineThrust() {
            // Only show a powerful flame if the main engine (W/Up) is pressed
            if (keys.W || keys.ArrowUp) {
                const cx = rocket.x + rocket.width / 2;
                const cy = rocket.y + rocket.height;
                
                // Flicker effect: random length and width for animation
                const flameLength = 20 + Math.random() * 25;
                const flameWidth = rocket.width * (0.8 + Math.random() * 0.4); 
                
                // 1. Reddish Outer Glow
                ctx.beginPath();
                ctx.moveTo(cx - flameWidth, cy); 
                ctx.lineTo(cx + flameWidth, cy);
                ctx.lineTo(cx + Math.random() * 5 - 2.5, cy + flameLength * 1.5); // Apex
                ctx.fillStyle = `rgba(255, 100, 0, ${0.4 + Math.random() * 0.2})`; 
                ctx.fill();

                // 2. Yellow Core
                ctx.beginPath();
                ctx.moveTo(cx - flameWidth * 0.5, cy); 
                ctx.lineTo(cx + flameWidth * 0.5, cy);
                ctx.lineTo(cx + Math.random() * 2 - 1, cy + flameLength);
                ctx.fillStyle = `rgba(255, 200, 0, ${0.8 + Math.random() * 0.2})`; 
                ctx.fill();
            }
        }


        /**
         * Draws the rocket ship as a simplified Starship (tall silver cylinder).
         */
        function drawRocket() {
            const radius = rocket.width / 2;
            const bodyHeight = rocket.height - radius;
            
            // 1. Main Body (Silver)
            ctx.fillStyle = '#CCCCCC'; 
            
            // Cylinder body
            ctx.fillRect(rocket.x, rocket.y + radius, rocket.width, bodyHeight);
            
            // Rounded top
            ctx.beginPath();
            ctx.arc(rocket.x + radius, rocket.y + radius, radius, Math.PI, 0);
            ctx.fill();
            
            // 2. Cockpit/Window (Darker section near top)
            ctx.fillStyle = '#333333';
            ctx.fillRect(rocket.x + 8, rocket.y + radius + 10, rocket.width - 16, 20);

            // 3. Engine Nozzles (Small circles at the bottom, Starship style)
            const nozzleY = rocket.y + rocket.height - 5;
            ctx.fillStyle = '#ff6600'; 
            
            // Left nozzle
            ctx.beginPath();
            ctx.arc(rocket.x + radius / 2 - 3, nozzleY, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Center nozzle
            ctx.beginPath();
            ctx.arc(rocket.x + radius, nozzleY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Right nozzle
            ctx.beginPath();
            ctx.arc(rocket.x + rocket.width - radius / 2 + 3, nozzleY, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Class for creating obstacles (Asteroids) with irregular shapes and sizes.
         */
        class Asteroid {
            constructor(x, y, radius, speed) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.speed = speed;
                this.color = '#808080';
                this.points = this.generateIrregularShape(radius, 6 + Math.floor(Math.random() * 4)); 
            }

            /**
             * Generates an array of points for an irregular polygon, giving a rock shape.
             */
            generateIrregularShape(baseRadius, numPoints) {
                const points = [];
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    // Randomize radius slightly more for aggressive shape changes
                    const randomizedRadius = baseRadius * (0.6 + Math.random() * 0.8); // 60% to 140% of base
                    points.push({
                        x: Math.cos(angle) * randomizedRadius,
                        y: Math.sin(angle) * randomizedRadius
                    });
                }
                return points;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                
                // Draw the irregular shape
                ctx.moveTo(this.x + this.points[0].x, this.y + this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.x + this.points[i].x, this.y + this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
            }

            update() {
                this.y += this.speed;
            }
        }

        /**
         * Checks for collision between the rocket and an asteroid.
         */
        function checkCollision(asteroid) {
            // Simplified collision check using the asteroid's bounding radius against the rocket's center point
            const rocketCenterX = rocket.x + rocket.width / 2;
            const rocketCenterY = rocket.y + rocket.height / 2;
            
            // Use the asteroid's effective radius (max point distance)
            const effectiveRadius = asteroid.radius * 1.4; 

            const distanceX = asteroid.x - rocketCenterX;
            const distanceY = asteroid.y - rocketCenterY;

            const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
            return distanceSquared < (effectiveRadius * effectiveRadius);
        }

        // --- Game Logic ---

        /**
         * Adjusts global game speed and spawn rate based on score.
         */
        function updateDifficulty() {
            const newLevel = Math.floor(score / 15) + 1; // Level up faster (every 15 points)
            if (newLevel > difficultyLevel) {
                difficultyLevel = newLevel;
                
                // Increased speed scaling for faster difficulty spike
                globalSpeed = 2 + (difficultyLevel * 1.0); 
                
                // Faster reduction in spawn rate (more asteroids, lower min spawn frame is 10)
                obstacleSpawnRate = Math.max(10, 60 - (difficultyLevel * 10)); 
                
                levelDisplay.textContent = `Level: ${difficultyLevel}`;
            }
        }

        /**
         * Spawns new asteroids based on the current spawn rate.
         */
        function spawnObstacles() {
            obstacleCount++;
            if (obstacleCount >= obstacleSpawnRate) {
                // Larger range of sizes for obstacles
                const minRadius = 15;
                const maxRadius = 40;
                const radius = Math.random() * (maxRadius - minRadius) + minRadius;
                
                const x = Math.random() * (CW - radius * 2) + radius;
                const speed = globalSpeed + Math.random() * 1.5; 

                obstacles.push(new Asteroid(x, -radius, radius, speed));
                obstacleCount = 0;
            }
        }

        /**
         * Main game update loop.
         * @param {number} timestamp 
         */
        function gameLoop(timestamp) {
            if (!isRunning) return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // 1. Clear Canvas 
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CW, CH);

            // 2. Rocket Movement Update (360-degree movement)
            rocket.velX = 0;
            rocket.velY = 0; 
            
            // Horizontal
            if (keys.A || keys.ArrowLeft) rocket.velX = -rocket.speed;
            if (keys.D || keys.ArrowRight) rocket.velX = rocket.speed;
            // Vertical
            if (keys.W || keys.ArrowUp) rocket.velY = -rocket.speed;
            if (keys.S || keys.ArrowDown) rocket.velY = rocket.speed;

            // Apply movement scaled by delta time
            const scaleFactor = deltaTime / 16.66;
            rocket.x += rocket.velX * scaleFactor;
            rocket.y += rocket.velY * scaleFactor;

            // Boundary checking (360-degree boundaries)
            if (rocket.x < 0) rocket.x = 0;
            if (rocket.x > CW - rocket.width) rocket.x = CW - rocket.width;
            if (rocket.y < 0) rocket.y = 0;
            if (rocket.y > CH - rocket.height) rocket.y = CH - rocket.height;

            // 3. Obstacle Spawning and Updating
            spawnObstacles();
            
            let hit = false;
            obstacles = obstacles.filter(asteroid => {
                asteroid.update();
                asteroid.draw();

                // Check for collision
                if (checkCollision(asteroid)) {
                    hit = true;
                    return false; 
                }

                // Keep asteroid if it's visible
                return asteroid.y < CH + asteroid.radius; 
            });

            // 4. Draw Rocket and Thrust
            drawEngineThrust(); // Draw fire first so rocket is on top
            drawRocket();

            // 5. Check Game State
            if (hit) {
                endGame();
                return;
            }

            // 6. Request next frame
            requestAnimationFrame(gameLoop);
        }

        /**
         * Initiates a new game session.
         */
        window.startGame = function() {
            // Reset state
            score = 0;
            globalSpeed = 2;
            obstacleSpawnRate = 60;
            difficultyLevel = 1;
            obstacles = [];
            isRunning = true;
            gameOverModal.style.display = 'none';
            scoreDisplay.textContent = 'Score: 0';
            levelDisplay.textContent = `Level: 1`;
            
            // Set initial rocket position 
            resizeCanvas(); 
            rocket.x = CW / 2 - rocket.width / 2;
            rocket.y = CH * 0.75 - rocket.height / 2; // Starts slightly low

            // Start score timer
            if (scoreInterval) clearInterval(scoreInterval);
            scoreInterval = setInterval(() => {
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
                updateDifficulty();
            }, 1000); // 1 point per second

            // Start the main loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // --- Game End ---
        function endGame() {
            isRunning = false;
            if (scoreInterval) clearInterval(scoreInterval);
            finalScoreDisplay.textContent = score;
            gameOverModal.style.display = 'flex';
        }

        // Start the game immediately on load
        window.onload = function() {
            resizeCanvas();
            startGame();
        }

    </script>
</body>
</html>